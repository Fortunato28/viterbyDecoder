#ifndef VITERBY_H
#define VITERBY_H

#include <stdint.h>
#include <stdbool.h>

//******************************Удалить*******************************************
#define S 64
#define N 2

/**
 * @brief массив переходов конечного автомата
 *        Количество возможных состояний конечного автомата S.
 *        Каждое состояние автомата соответствует конкретному состоянию регистра
 *        кодера. Массив реализован в соответствии с логикой структуры данных
 *        "двоичное дерево", а значит относительно любого состояния можно найти
 *        по индексу (i) его левого потомка (2i) и правого потомка (2i+1).
 *        Также дерево закольцовано, что позволяет перемещаться по нему по модулю 32 (S/2).
 */
size_t jumpArray[S];

//*******************************Макросы******************************************
/**
 * @brief максимальная глубина поиска предположительно верной последовательности
 */
#define DEPTH 10
/**
 * @brief максимальная глубина поиска предположительно верной последовательности
 */
#define LOW_BIT 0x1
///*****************************Структуры******************************************

/**
 * @brief структура sPath описывает путь от текущего узла до узла, в котором  схо-
 *        дятся другие пути.
 * Члены структуры:
 *  metric      - метрика Хэмминга текущего пути
 *  nodeSize    - количество записанных вершин
 *  currentNode - перечень текущих вершин
 */
typedef struct
{
    unsigned int metric;
    unsigned int nodeSize;
    unsigned int currentNode[S];
}sPath;

/**
 * @brief структура sTree описывает дерево вероятных путей
 * Члены структуры:
 *  data        - значение посещенного узла
 *  metric      - метрика Хэмминга для текущего узла
 *  codeIndex   - индекс массива последовательностей, при котором произошло ветвление дерева путей
 *  left        - указатель на левое поддерево
 *  right       - указатель на правое поддерево
 *  parent      - указатель на родительский узел
 */
typedef struct
{
    unsigned int data;
    unsigned int metric;
    unsigned int codeIndex;
    struct sTree *left;
    struct sTree *right;
    struct sTree *parent;
} sTree;

/*****************************Переменные*****************************************
 * @brief дерево вероятных путей от текущего узла
 */
sTree *pathTree;
 /* @brief выделение текущего дибита
 */
bool dibit[N];
//******************************Функции*******************************************
/**
 * @brief функция запускает декодирование слова по алгоритму Витерби
 * @param
 *  codedStream - закодированная информация
 *  lenCoded - количество переданной информации (в битах)
 *  decodedStream - декодированные данные
 *  lenDecoded - размер выходных декодированных данных
 */
void getDecode(void *coded, size_t lenCoded,
               void *decoded, size_t lenDecoded);

/**
 * @brief функция, очищающая массив вероятных путей
 * @param
 *  sPath path[S] - массив вероятных путей
 *  pathSize - размер массива вероятныx путей
 */
void clearPath(sPath path[S], size_t pathSize);

/**
 * @brief функция получения вероятных путей по алгоритму Витерби
 * @param
 *  tree - указатель на текущий узел дерева возможных путей
 *  treeHight - текущая высота дерева (индекс массива последовательносте из N-символов)
 *  depth - глубина поиска
 *  codedStream - закодированная информация
 *  len - количество переданной информации (в битах)
 */
sTree *viterby(sTree *tree, size_t *treeHight, uint32_t *depth, void *codedStream, size_t len);

/**
 * @brief функуция выделения двух текущих битов закодированной последовательности,
 *  	  необходимых для сравнения со значениями переходов при построении кодовой решетки
 * @param
 *	dibit - массив, в который будут помещены бита
 *  treeHight - текущая высота дерева (текущая двойка битов)
 *  codedStream - закодированная информация
 *  len - количество переданной информации (в битах)
 */
void selectDibits(bool dibit[N], uint32_t *treeHight, void *codedStream, size_t len);

/**
 * @brief функция добавляет в дерево вероятных путей новый узел
 * @param
 *  state - значение нового узла дерева
 *  treeHight - индекс массива последовательностей, при котором произошло ветвление
 *  node - указатель на новый узел дерева
 *  left -  флаг, указывающий, в какое поддерево будет добавлен нвый узел.
 *          При left = true узел будет добавлен в левое поддерево, иначе - в правое.
 */
sTree *addNode(size_t state, size_t treeHight, sTree *node, bool left);

/**
 * @brief функция добавляет в поддерево вероятных путей новый узел
 * @param
 *  state - значение нового узла дерева
 *  treeHight - индекс массива последовательностей, при котором произошло ветвление
 *  node - указатель на новый узел дерева
 *  left -  флаг, указывающий, в какое поддерево будет добавлен нвый узел.
 *  parent - указатель на родительский узел
 */
sTree * createBranch(size_t state, size_t treeHight,
                     sTree *node, sTree *parent, bool left);
/**
 * @brief фкнуция подсчета метрики Хэмминга.
 *        Метрика Хэмминга рассчитывается как количество
 *        различающихся символов в двух массивах.
 * @param
 *  tree - указатель на текущий узел дерева путей
 *  array_1 - указатель на первый массив
 *  array_2 - указатель на второй массив
 */
void hammingCounter(sTree *tree, bool *array_1, bool *array_2);
#endif // VITERBY_H





























